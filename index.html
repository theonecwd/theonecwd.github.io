<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="The One">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="The One">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="The One">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>The One</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">The One</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/14/code/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="The One">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="The One">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/14/code/" class="post-title-link" itemprop="url">code</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-03-14 16:10:56 / 修改时间：16:12:13" itemprop="dateCreated datePublished" datetime="2021-03-14T16:10:56+08:00">2021-03-14</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line">extern long populate_vma_page_range(struct vm_area_struct *vma,</span><br><span class="line">		unsigned long start, unsigned long end, int *nonblocking);</span><br><span class="line"></span><br><span class="line">int get_pid_and_addr(const char __user *ubuf, pid_t *pid, unsigned long *addr, size_t count)</span><br><span class="line">&#123;</span><br><span class="line">	char *pos &#x3D; NULL;</span><br><span class="line">	char *pid_str &#x3D; NULL;</span><br><span class="line">	char *addr_str &#x3D; NULL;</span><br><span class="line">	char *kbuf &#x3D; NULL;</span><br><span class="line">	int ret &#x3D; -EINVAL;</span><br><span class="line"></span><br><span class="line">	kbuf &#x3D; kmalloc(count, GFP_KERNEL);</span><br><span class="line">	if (!kbuf)</span><br><span class="line">		return -ENOMEM;</span><br><span class="line"></span><br><span class="line">	if (copy_from_user(kbuf, ubuf, count)) &#123;</span><br><span class="line">		ret &#x3D; -EFAULT;</span><br><span class="line">		goto free;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	kbuf[count] &#x3D; 0;</span><br><span class="line">	while (*pos) &#123;</span><br><span class="line">		if (*pos &#x3D;&#x3D; &#39; &#39;) &#123;</span><br><span class="line">			*pos &#x3D; 0;</span><br><span class="line">			addr_str &#x3D; pos + 1;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		pos++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (kstrtoint(pid_str, 10, pid) || kstrtoul(addr_str, 16, addr))</span><br><span class="line">		goto free;</span><br><span class="line"></span><br><span class="line">	if (*pid &lt;&#x3D; 0)</span><br><span class="line">		goto free;</span><br><span class="line"></span><br><span class="line">	if (*addr &#x3D;&#x3D; 0)</span><br><span class="line">		goto free;</span><br><span class="line"></span><br><span class="line">	ret &#x3D; 0;</span><br><span class="line">	printk(KERN_INFO &quot;pid is %d, addr is %lx\n&quot;, *pid, *addr);</span><br><span class="line"></span><br><span class="line">free:</span><br><span class="line">	kfree(kbuf);</span><br><span class="line"></span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">unsigned long get_value_locked(struct vm_area_struct *vma,</span><br><span class="line">		unsigned long addr, unsigned long *value)</span><br><span class="line">&#123;</span><br><span class="line">	int ret;</span><br><span class="line">	unsigned long start_addr;</span><br><span class="line">	unsigned long end_addr;</span><br><span class="line">	unsigned long offset;</span><br><span class="line">	unsigned long *kaddr;</span><br><span class="line">	struct page *page;</span><br><span class="line">	int locked &#x3D; 1;</span><br><span class="line"></span><br><span class="line">	offset &#x3D; addr &amp; (PAGE_SIZE - 1);</span><br><span class="line">	start_addr &#x3D; addr &amp; PAGE_MASK;</span><br><span class="line">	end_addr &#x3D; start_addr + PAGE_SIZE;</span><br><span class="line"></span><br><span class="line">	ret &#x3D; populate_vma_page_range(vma, start_addr, end_addr, &amp;locked);</span><br><span class="line">	if (ret &lt; 0) &#123;</span><br><span class="line">		printk(KERN_ERR &quot;populate vma error\n&quot;);</span><br><span class="line">		return ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	page &#x3D; follow_page(vma, addr, FOLL_GET);</span><br><span class="line">	BUG_ON(!page);</span><br><span class="line"></span><br><span class="line">	kaddr &#x3D; kmap(page);</span><br><span class="line">	kaddr +&#x3D; offset;</span><br><span class="line">	*value &#x3D; *kaddr;</span><br><span class="line">	kunmap(page);</span><br><span class="line"></span><br><span class="line">	put_page(page);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static ssize_t get_val_by_uaddr(struct file *file, const char __user *buffer,</span><br><span class="line">		size_t count, loff_t *pos)</span><br><span class="line">&#123;</span><br><span class="line">	pid_t pid;</span><br><span class="line">	unsigned long value;</span><br><span class="line">	unsigned long addr; &#x2F;* TODO *&#x2F;</span><br><span class="line">	struct task_struct *task &#x3D; NULL;</span><br><span class="line">	struct mm_struct *mm &#x3D; NULL;</span><br><span class="line">	struct vm_area_struct *vma &#x3D; NULL;</span><br><span class="line">	ssize_t ret &#x3D; -EINVAL;</span><br><span class="line"></span><br><span class="line">	if (count &lt; 0)</span><br><span class="line">		return -EINVAL;</span><br><span class="line"></span><br><span class="line">	ret &#x3D; get_pid_and_addr(buffer, &amp;pid, &amp;addr, count);</span><br><span class="line">	if (ret &lt; 0)</span><br><span class="line">		return ret;</span><br><span class="line"></span><br><span class="line">	ret &#x3D; -EINVAL;</span><br><span class="line">	rcu_read_lock();</span><br><span class="line">	task &#x3D; find_task_by_vpid(pid);</span><br><span class="line">	if (!task) &#123;</span><br><span class="line">		printk(KERN_ERR &quot;find no task\n&quot;);</span><br><span class="line">		goto unlock_rcu;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mm &#x3D; get_task_mm(task);</span><br><span class="line">	if (!mm) &#123;</span><br><span class="line">		printk(KERN_ERR &quot;find no mm\n&quot;); &#x2F;* TODO 删除打印 *&#x2F;</span><br><span class="line">		goto unlock_rcu;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mmap_read_lock(mm);</span><br><span class="line">	vma &#x3D; find_vma(mm, addr);</span><br><span class="line">	if (!vma) &#123;</span><br><span class="line">		printk(KERN_ERR &quot;not valid address\n&quot;);</span><br><span class="line">		goto unlock_mmap;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ret &#x3D; get_value_locked(vma, addr, &amp;value);</span><br><span class="line">	if (ret &lt; 0)</span><br><span class="line">		goto unlock_mmap;</span><br><span class="line"></span><br><span class="line">	ret &#x3D; count;</span><br><span class="line">	printk(KERN_INFO &quot;value is %lu\n&quot;, value);</span><br><span class="line"></span><br><span class="line">unlock_mmap:</span><br><span class="line">	mmap_read_unlock(mm);</span><br><span class="line"></span><br><span class="line">put_mm:</span><br><span class="line">	mmput(mm);</span><br><span class="line"></span><br><span class="line">unlock_rcu:</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static const struct proc_ops get_val_proc_fops &#x3D; &#123;</span><br><span class="line">	.proc_write &#x3D; get_val_by_uaddr,</span><br><span class="line">	.proc_lseek &#x3D; noop_llseek, &#x2F;* TODO *&#x2F;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static int __init proc_get_val_by_uaddr(void)</span><br><span class="line">&#123;</span><br><span class="line">	proc_create(&quot;get_val_by_uaddr&quot;, 0220, NULL, &amp;get_val_proc_fops);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">fs_initcall(proc_get_val_by_uaddr);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/11/22/Hexo-How-To/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="The One">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="The One">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/22/Hexo-How-To/" class="post-title-link" itemprop="url">Hexo How-To</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-22 17:07:54" itemprop="dateCreated datePublished" datetime="2020-11-22T17:07:54+08:00">2020-11-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>本文会介绍, hexo的使用
文章欢迎转载,但转载时请保留本段文字,并置于文章的顶部,作者:陈乐天,本文原文地址:https://theonecwd.github.io/2020/03/15/Hexo-How-To/#more</p>
</blockquote>
<p>hexo是一款可以使用markdown来写博客的工具，方便部署，本文介绍如何使用hexo</p>
<h2 id="安装包管理工具"><a href="#安装包管理工具" class="headerlink" title="安装包管理工具"></a>安装包管理工具</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install npm</span><br></pre></td></tr></table></figure>

<h2 id="init-a-hexo-project"><a href="#init-a-hexo-project" class="headerlink" title="init a hexo project"></a>init a hexo project</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init</span><br></pre></td></tr></table></figure>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/11/22/Hexo-How-To/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/08/%E7%BA%BF%E7%A8%8B%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F-%E4%BA%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="The One">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="The One">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/08/%E7%BA%BF%E7%A8%8B%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F-%E4%BA%8C/" class="post-title-link" itemprop="url">线程局部变量(二)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-08 11:34:40" itemprop="dateCreated datePublished" datetime="2020-03-08T11:34:40+08:00">2020-03-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-11-22 15:44:11" itemprop="dateModified" datetime="2020-11-22T15:44:11+08:00">2020-11-22</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>本文会介绍,关键字__thread定义的TLS变量的实现.</p>
</blockquote>
<blockquote>
<p>文章欢迎转载,但转载时请保留本段文字,并置于文章的顶部,作者:陈乐天,本文原文地址:<br><a target="_blank" rel="noopener" href="https://theonecwd.github.io/2020/03/08/%E7%BA%BF%E7%A8%8B%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F-%E4%BA%8C/#more">https://theonecwd.github.io/2020/03/08/%E7%BA%BF%E7%A8%8B%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F-%E4%BA%8C/#more</a></p>
</blockquote>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在前一篇文章中,<br><a target="_blank" rel="noopener" href="https://theonecwd.github.io/2020/03/07/%E7%BA%BF%E7%A8%8B%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F-%E4%B8%80/#more">线程局部变量(一)</a><br>分析了基于POSIX线程库的线程局部变量(TLS)的实现,本文介绍基于关键字__thread的TLS的实现.<br>TLS变量的实现依赖于glibc,内核,编译器, 本文重点关注内核在TLS中的作用.</p>
<h2 id="用户态使用"><a href="#用户态使用" class="headerlink" title="用户态使用"></a>用户态使用</h2><p>下面是一个简单的用户态代码示例,通过关键字__thread定义了一个线程局部变量,<br>在线程1和线程2中分别对该值赋值,并打印该值.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line"></span><br><span class="line">__thread int tls_val &#x3D; 3;</span><br><span class="line"></span><br><span class="line">void* thread(void* arg)</span><br><span class="line">&#123;</span><br><span class="line">        tls_val +&#x3D; *(int *)arg;</span><br><span class="line">        while (1) &#123;</span><br><span class="line">		printf(&quot;thread:%lu Thread Local Storage is %d\n&quot;, pthread_self(), tls_val);</span><br><span class="line">                sleep(2)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	pthread_t thid1;</span><br><span class="line">	pthread_t thid2;</span><br><span class="line"></span><br><span class="line">        int pthread_1_val &#x3D; 1;</span><br><span class="line">        int pthread_2_val &#x3D; 2;</span><br><span class="line"></span><br><span class="line">	pthread_create(&amp;thid1, NULL, thread, (void *)&amp;pthread_1_val);</span><br><span class="line">	pthread_create(&amp;thid2, NULL, thread, (void *)&amp;pthread_2_val);</span><br><span class="line"></span><br><span class="line">	pthread_join(thid1, NULL);</span><br><span class="line">	pthread_join(thid2, NULL);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>TLS的实现依赖架构相关的寄存器,即thread pointer register,每个线程都有自己的TLS空间,<br>thread pointer register中直接或间接存储TLS空间的信息.在访问TLS变量的时候,<br>依赖thread pointer register,这里就涉及到对thread pointer register的赋值保存等.</p>
<blockquote>
<p>不同架构TLS空间有不同的内存布局,但是不变的是,thread pointer register中的值都与TLS地址空间相关.</p>
</blockquote>
<h3 id="主线程thread-pointer寄存器的赋值"><a href="#主线程thread-pointer寄存器的赋值" class="headerlink" title="主线程thread pointer寄存器的赋值"></a>主线程thread pointer寄存器的赋值</h3><p>Linux的可执行文件在启动过程中,会进行一系列的初始化<br>在初始化的过程中都会给主线程分配TLS空间,并给架构相关的thread pointer register赋值.<br>在aarch64下,tpidr_el0就是所对应的thread pointer register,TLS_INIT_TP宏给tpidr_el0寄存器赋值.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># define TLS_INIT_TP(tcbp) \</span><br><span class="line">  (&#123; __asm __volatile (&quot;msr tpidr_el0, %0&quot; : : &quot;r&quot; (tcbp)); NULL; &#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里所说的TLS的空间,在aarch64中,在源码中是与结构tcbhead_t对应的,tcbhead_t是用来管理各个模块的TLS变量</p>
</blockquote>
<h3 id="创建新线程"><a href="#创建新线程" class="headerlink" title="创建新线程"></a>创建新线程</h3><p>在调用pthread_create的时候也会为创建的线程分配TLS空间,分配的TLS空间作为clone的参数传递到内核,保存到内核<br>task_struct的thread.uw.tp_value中, 在clone系统调用中第5个参数就是TLS空间<br>调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE5(clone, unsigned long, clone_flags, unsigned long, newsp,</span><br><span class="line">                 int __user *, parent_tidptr,</span><br><span class="line">                 int __user *, child_tidptr,</span><br><span class="line">                 unsigned long, tls)</span><br><span class="line">#endif</span><br><span class="line">&#123;</span><br><span class="line">        struct kernel_clone_args args &#x3D; &#123;</span><br><span class="line">                .flags          &#x3D; (clone_flags &amp; ~CSIGNAL),</span><br><span class="line">                .pidfd          &#x3D; parent_tidptr,</span><br><span class="line">                .child_tid      &#x3D; child_tidptr,</span><br><span class="line">                .parent_tid     &#x3D; parent_tidptr,</span><br><span class="line">                .exit_signal    &#x3D; (clone_flags &amp; CSIGNAL),</span><br><span class="line">                .stack          &#x3D; newsp,</span><br><span class="line">                .tls            &#x3D; tls,</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        if (!legacy_clone_args_valid(&amp;args))</span><br><span class="line">                return -EINVAL;</span><br><span class="line"></span><br><span class="line">        return _do_fork(&amp;args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>顺着_do_fork的调用,一路跟下去, _do_fork ==&gt; copy_process ==&gt; copy_thread_tls.<br>创建一个新的task会调用copy_process,如果是用户态调用fork的场景,child task和parent task会共享同一片TLS空间;<br>如果是pthread_create创建线程的场景,会设置CLONE_SETTLS标记,该标记表明,已经为新创建的task分配的TLS空间,<br>则将地址空间保存到task_struct结构中,对应的值是从用户态通过参数一路传递下来的.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">int copy_thread_tls(unsigned long clone_flags, unsigned long stack_start,</span><br><span class="line">                unsigned long stk_sz, struct task_struct *p, unsigned long tls)</span><br><span class="line">&#123;</span><br><span class="line">        struct pt_regs *childregs &#x3D; task_pt_regs(p);</span><br><span class="line"></span><br><span class="line">        memset(&amp;p-&gt;thread.cpu_context, 0, sizeof(struct cpu_context));</span><br><span class="line"></span><br><span class="line">        &#x2F;*</span><br><span class="line">         * In case p was allocated the same task_struct pointer as some</span><br><span class="line">         * other recently-exited task, make sure p is disassociated from</span><br><span class="line">         * any cpu that may have run that now-exited task recently.</span><br><span class="line">         * Otherwise we could erroneously skip reloading the FPSIMD</span><br><span class="line">         * registers for p.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        fpsimd_flush_task_state(p);</span><br><span class="line"></span><br><span class="line">        &#x2F;* 如果不是内核线程 *&#x2F;</span><br><span class="line">        if (likely(!(p-&gt;flags &amp; PF_KTHREAD))) &#123;</span><br><span class="line">                *childregs &#x3D; *current_pt_regs();</span><br><span class="line">                childregs-&gt;regs[0] &#x3D; 0;</span><br><span class="line"></span><br><span class="line">                &#x2F;*</span><br><span class="line">                 * Read the current TLS pointer from tpidr_el0 as it may be</span><br><span class="line">                 * out-of-sync with the saved value.</span><br><span class="line">                 *&#x2F;</span><br><span class="line">                *task_user_tls(p) &#x3D; read_sysreg(tpidr_el0);</span><br><span class="line"></span><br><span class="line">                if (stack_start) &#123;</span><br><span class="line">                        if (is_compat_thread(task_thread_info(p)))</span><br><span class="line">                                childregs-&gt;compat_sp &#x3D; stack_start;</span><br><span class="line">                        else</span><br><span class="line">                                childregs-&gt;sp &#x3D; stack_start;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                &#x2F;*</span><br><span class="line">                 * If a TLS pointer was passed to clone, use it for the new</span><br><span class="line">                 * thread.</span><br><span class="line">                 *&#x2F;</span><br><span class="line">                if (clone_flags &amp; CLONE_SETTLS)</span><br><span class="line">                        p-&gt;thread.uw.tp_value &#x3D; tls;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">                ......</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="context-switch"><a href="#context-switch" class="headerlink" title="context switch"></a>context switch</h3><p>在进程切换的时候,要将tpidr_el0寄存器中的值保存到prev task中,<br>然后将next task中的thread.uw.tp_value保存到tpidr_el0寄存器中.<br>调用路径如下:<br>context_switch ==&gt; switch_to ==&gt; __switch_to ==&gt; tls_thread_switch</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static void tls_thread_switch(struct task_struct *next)</span><br><span class="line">&#123;</span><br><span class="line">        tls_preserve_current_state();</span><br><span class="line"></span><br><span class="line">        if (is_compat_thread(task_thread_info(next)))</span><br><span class="line">                write_sysreg(next-&gt;thread.uw.tp_value, tpidrro_el0);</span><br><span class="line">        else if (!arm64_kernel_unmapped_at_el0())</span><br><span class="line">                write_sysreg(0, tpidrro_el0);</span><br><span class="line"></span><br><span class="line">        write_sysreg(*task_user_tls(next), tpidr_el0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p>上面讲的内容主要是内核在TLS变量实现中所做的操作,主要是thread pointer寄存器的保存和恢复.<br>如果仅仅是讲到这里可能会让人意犹未尽,读者心里也许还有很多疑问.<br>下面会从两个方面概述一下TLS其他方面的知识, 之所以是概述,是因为这里面涉及的东西太多了,<br>包括链接,重定位,运行时库等, 其中任何一点如果要讲清楚的话都需要大量的篇幅.<br>我会下列举一些参考资料,有兴趣的读者可以进一步学习.</p>
<h3 id="TLS变量的访问"><a href="#TLS变量的访问" class="headerlink" title="TLS变量的访问"></a>TLS变量的访问</h3><p>这部分讲的是如何通过一个变量名来访问本线程对应的变量,这里涉及到链接,重定位,运行时库等.</p>
<p>使用__thread关键字时,经过编译后,生成的目标文件中会将__thread关键字修饰的变量放到目标文件的tdata或者tbss段中,<br>与data段和bss段类似, tdata中表示是已经初始化的变量, tbss表示是未初始化的变量.<br>这些段是作为init data来填充每个线程的TLS空间.</p>
<p>对于每一个新创建的线程来说,他们的TLS空间中的数据都是一样的,都是用tdata段和tbss段来初始化的.<br>整体上来看init data和各个线程的TLS空间中的变量是同源多实体的关系, 来源都是init data, 线程的TLS空间是一个实体.</p>
<p>知道了这些还不够,上面仅仅是初始化.<br>那么如何访问一个TLS变量呢?<br>假设,根据thread pointer register我们知道了TLS空间的基地址,那么如果我们知道了每个变量在TLS空间的offset,是不是就可以访问<br>TLS变量了.<br>编译器和ld.so确实是按照这个方法做的,但是要比上面说的复杂许多.</p>
<p>glibc为每一个线程分配一个独立的TLS空间,TLS空间中包含多个block, 每一个block表示一个目标文件<br>中的TLS变量. 这些TLS变量由每个目标文件的tdata段和tbss段来填充,在访问变量的时候,先确定是哪个block,然后在确认在该block中的偏移就<br>OK了.<br>当然说的简单,实际实现过程中要考虑的东西很多,感兴趣的同学可以参考glibc代码.</p>
<p>参考资料:<br><a target="_blank" rel="noopener" href="https://chao-tic.github.io/blog/2018/12/25/tls">A Deep dive into (implicit) Thread Local Storage</a></p>
<h3 id="TLS空间分配模型"><a href="#TLS空间分配模型" class="headerlink" title="TLS空间分配模型"></a>TLS空间分配模型</h3><p>为什么要分成一个个block呢?<br>设想一下这种场景:<br>一个进程中有多个线程,在众多线程中有一个比较特殊,这个线程只访问一个目标文件中定义的局部变量,<br>那么是否有必要把其他目标文件的init data也拷贝到TLS区域中呢.这就涉及到下面要讲的TLS空间分配模型的问题.</p>
<p>TLS空间的分配可能采用静态模型,也可能采用动态模型.<br>如果采用静态模型,则在线程创建的时候已经为每一个目标文件(block)指定了TLS空间中的位置.<br>动态模型在访问的时候会给目标文件在TLS空间中分配空间.<br>感兴趣的同学可以参考下面的资料.</p>
<p>参考资料:<br><a target="_blank" rel="noopener" href="https://uclibc.org/docs/tls.pdf">ELF Handling For Thread-Local Storage</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/07/%E7%BA%BF%E7%A8%8B%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F-%E4%B8%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="The One">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="The One">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/07/%E7%BA%BF%E7%A8%8B%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F-%E4%B8%80/" class="post-title-link" itemprop="url">线程局部变量(一)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-07 10:49:44" itemprop="dateCreated datePublished" datetime="2020-03-07T10:49:44+08:00">2020-03-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-11-22 15:44:11" itemprop="dateModified" datetime="2020-11-22T15:44:11+08:00">2020-11-22</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>本文会介绍, POSIX库定义的TLS变量的实现.<br>文章欢迎转载,但转载时请保留本段文字,并置于文章的顶部,作者:陈乐天,本文原文地址:<a target="_blank" rel="noopener" href="https://theonecwd.github.io/2020/03/07/%E7%BA%BF%E7%A8%8B%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F-%E4%B8%80/#more">https://theonecwd.github.io/2020/03/07/%E7%BA%BF%E7%A8%8B%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F-%E4%B8%80/#more</a></p>
</blockquote>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>线程局部变量(Thread Local Storage, TLS)，顾名思义，变量是属于线程的，针对同一变量，不同的线程可以有不同的值.<br>TLS的使用方法有两种，一种是通过POSIX线程库，另外一种是通过__thread关键字的方式，<br>本文介绍POSIX线程库线程局部变量的使用和glibc实现.</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>下面是一个简单的使用示例，在主线程里面创建了两个线程，每一个线程通过pthread_setspecific设置了自己的pthread_key_t对应的value，<br>通过pthread_getspecific来获取线程变量的值.<br>主线程里面在创建线程1和线程2的时候sleep了3秒，保证两个线程不会并发访问全局变量key_val，其实这里应该用锁保证，<br>为了不被其他东西干扰，简单起见，这里使用sleep来演示验证.<br>通过下面的示例，可以发现同一个pthread_key_t代表的线程变量，在不同线程中有不同的值.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">pthread_key_t key;</span><br><span class="line">int key_val &#x3D; 5;</span><br><span class="line"></span><br><span class="line">void* thread(void* arg)</span><br><span class="line">&#123;</span><br><span class="line">	pthread_setspecific(key, (void *) key_val);</span><br><span class="line">	key_val++;</span><br><span class="line">	</span><br><span class="line">	printf(&quot;thread:%lu Thread Local Storage is %d\n&quot;, pthread_self(), (int)pthread_getspecific(key));</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	pthread_t thid1;</span><br><span class="line">	pthread_t thid2;</span><br><span class="line"></span><br><span class="line">	pthread_key_create(&amp;key, NULL);</span><br><span class="line"></span><br><span class="line">	pthread_create(&amp;thid1, NULL, thread, NULL);</span><br><span class="line">        sleep(3);</span><br><span class="line">	pthread_create(&amp;thid2, NULL, thread, NULL);</span><br><span class="line"></span><br><span class="line">	pthread_join(thid1, NULL);</span><br><span class="line">	pthread_join(thid2, NULL);</span><br><span class="line"></span><br><span class="line">	pthread_key_delete(key);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="glibc实现"><a href="#glibc实现" class="headerlink" title="glibc实现"></a>glibc实现</h2><p>在glibc中为每个线程都分配了TLS空间,当通过pthread_key_t来访问TLS变量的时候,访问的是自己线程空间的值,<br>所以针对同一个TLS变量,每个线程的值都可以不一样.<br>下面通过glibc的pthread_key_create, pthread_setspecific, pthread_getspecific,pthread_key_delete来具体分析TLS的实现,<br>TLS的实现是架构相关的, TLS实现中依赖一个架构相关的thread pointer register, 这里以aarch64为例来分析.</p>
<ol>
<li>pthread_key_create<br>pthread_key_create的实现在glibcnptl/pthread_key_create.c文件中,<br>具体实现很简单, PTHREAD_KEYS_MAX为1024, 通过循环来查找第一个未使用的key.<br>key在范围在0 ~ 1024之间,也就是说最多有1024个TLS变量,将找到的key返回给调用者,<br>之后可以通过这个key来索引TLS变量的值.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line">__pthread_key_create (pthread_key_t *key, void (*destr) (void *)) </span><br><span class="line">&#123;</span><br><span class="line">  &#x2F;* Find a slot in __pthread_keys which is unused.  *&#x2F;</span><br><span class="line">  for (size_t cnt &#x3D; 0; cnt &lt; PTHREAD_KEYS_MAX; ++cnt)</span><br><span class="line">    &#123;   </span><br><span class="line">      uintptr_t seq &#x3D; __pthread_keys[cnt].seq;</span><br><span class="line"></span><br><span class="line">      if (KEY_UNUSED (seq) &amp;&amp; KEY_USABLE (seq)</span><br><span class="line">          &#x2F;* We found an unused slot.  Try to allocate it.  *&#x2F;</span><br><span class="line">          &amp;&amp; ! atomic_compare_and_exchange_bool_acq (&amp;__pthread_keys[cnt].seq,</span><br><span class="line">                                                     seq + 1, seq))</span><br><span class="line">        &#123;</span><br><span class="line">          &#x2F;* Remember the destructor.  *&#x2F;</span><br><span class="line">          __pthread_keys[cnt].destr &#x3D; destr;</span><br><span class="line"></span><br><span class="line">          &#x2F;* Return the key to the caller.  *&#x2F;</span><br><span class="line">          *key &#x3D; cnt;</span><br><span class="line"></span><br><span class="line">          &#x2F;* The call succeeded.  *&#x2F;</span><br><span class="line">          return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">  return EAGAIN;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>pthread_setspecific<br>pthread_setpecific的实现在nptl/pthread_setspecific.c文件中,在该函数中会先获取线程struct pthread的地址,<br>然后根据key设置当前线程该key对应的值,如果值所在的空间没有分配则先分配空间,分配的空间保存在struct pthread<br>的specific变量中, struct pthread使用一个32 * 32的二维数组保存key的所对应的值.</li>
</ol>
<p>第10行是一个架构相关的实现, THREAD_SELF宏中使用__builtin_thread_pointer来获取thread pointer的值,<br>并通过thread pointer获得了本线程struct pthread的地址.<br>thread pointer在aarch64中是保存在tpidr_el0寄存器中, 在EL0级别可以读写该寄存器,tpidr_el0中保存的不是struct pthread的地址,<br>而是tcbhead_t的地址,但是这两个地址是有关系的,如下所示,至于tcbhead_t是干什么用的,这个涉及到TLS变量的另一个用法,<br>通过关键字__thread定义的TLS变量保存在tcbhead_t区域中,<br>这个会有其他文章来介绍.POSIX线程库使用的TLS变量保存在struct pthread区域中.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">--------------------------------------</span><br><span class="line">|		     |	    	     |</span><br><span class="line">|   struct pthread   |   tcbhead_t   |</span><br><span class="line">|		     |	    	     |</span><br><span class="line">--------------------------------------</span><br></pre></td></tr></table></figure>

<p>在介绍设置TLS值之前有必要先介绍下struct pthread中存储TLS变量的结构.<br>PTHREAD_KEY_2NDLEVEL_SIZE的值是32,线程局部变量保存在一个32 * 32 = 1024的二维数组里,<br>在struct pthread结构中specific表示这个二维数组.<br>specific数组的打小是32, specific的每一个成员是一个指针,这个指针指向了32个struct pthread_key_data变量.<br>在struct pthread结构分配的时候会默认分配32个TLS变量,<br>这32个TLS变量保存在specific_1stblock中,specific_1stblock占据了specific数组中第0个位置,<br>具体实现在pthread_create代码中,读者可自行分析.</p>
<p>介绍了这些之后, 14到65行的代码的目的就呼之欲出了.<br>如果key &lt; 32,则TLS空间在分配struct pthread的时候已经默认分配了,直接设置TLS变量的值.<br>如果key &gt;=32,则需要确定该TLS变量所在的行和列,如果没有分配空间则先分配空间,如果已经分配空间则直接设置.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line">__pthread_setspecific (pthread_key_t key, const void *value)</span><br><span class="line">&#123;</span><br><span class="line">  struct pthread *self;</span><br><span class="line">  unsigned int idx1st;</span><br><span class="line">  unsigned int idx2nd;</span><br><span class="line">  struct pthread_key_data *level2;</span><br><span class="line">  unsigned int seq;</span><br><span class="line"></span><br><span class="line">  self &#x3D; THREAD_SELF;</span><br><span class="line"></span><br><span class="line">  &#x2F;* Special case access to the first 2nd-level block.  This is the</span><br><span class="line">     usual case.  *&#x2F;</span><br><span class="line">  if (__glibc_likely (key &lt; PTHREAD_KEY_2NDLEVEL_SIZE))</span><br><span class="line">    &#123;</span><br><span class="line">      &#x2F;* Verify the key is sane.  *&#x2F;</span><br><span class="line">      if (KEY_UNUSED ((seq &#x3D; __pthread_keys[key].seq)))</span><br><span class="line">	&#x2F;* Not valid.  *&#x2F;</span><br><span class="line">	return EINVAL;</span><br><span class="line"></span><br><span class="line">      level2 &#x3D; &amp;self-&gt;specific_1stblock[key];</span><br><span class="line"></span><br><span class="line">      &#x2F;* Remember that we stored at least one set of data.  *&#x2F;</span><br><span class="line">      if (value !&#x3D; NULL)</span><br><span class="line">	THREAD_SETMEM (self, specific_used, true);</span><br><span class="line">    &#125;</span><br><span class="line">  else</span><br><span class="line">    &#123;</span><br><span class="line">      if (key &gt;&#x3D; PTHREAD_KEYS_MAX</span><br><span class="line">	  || KEY_UNUSED ((seq &#x3D; __pthread_keys[key].seq)))</span><br><span class="line">	&#x2F;* Not valid.  *&#x2F;</span><br><span class="line">	return EINVAL;</span><br><span class="line"></span><br><span class="line">      idx1st &#x3D; key &#x2F; PTHREAD_KEY_2NDLEVEL_SIZE;</span><br><span class="line">      idx2nd &#x3D; key % PTHREAD_KEY_2NDLEVEL_SIZE;</span><br><span class="line"></span><br><span class="line">      &#x2F;* This is the second level array.  Allocate it if necessary.  *&#x2F;</span><br><span class="line">      level2 &#x3D; THREAD_GETMEM_NC (self, specific, idx1st);</span><br><span class="line">      if (level2 &#x3D;&#x3D; NULL)</span><br><span class="line">	&#123;</span><br><span class="line">	  if (value &#x3D;&#x3D; NULL)</span><br><span class="line">	    &#x2F;* We don&#39;t have to do anything.  The value would in any case</span><br><span class="line">	       be NULL.  We can save the memory allocation.  *&#x2F;</span><br><span class="line">	    return 0;</span><br><span class="line"></span><br><span class="line">	  level2</span><br><span class="line">	    &#x3D; (struct pthread_key_data *) calloc (PTHREAD_KEY_2NDLEVEL_SIZE,</span><br><span class="line">						  sizeof (*level2));</span><br><span class="line">	  if (level2 &#x3D;&#x3D; NULL)</span><br><span class="line">	    return ENOMEM;</span><br><span class="line"></span><br><span class="line">	  THREAD_SETMEM_NC (self, specific, idx1st, level2);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;* Pointer to the right array element.  *&#x2F;</span><br><span class="line">      level2 &#x3D; &amp;level2[idx2nd];</span><br><span class="line"></span><br><span class="line">      &#x2F;* Remember that we stored at least one set of data.  *&#x2F;</span><br><span class="line">      THREAD_SETMEM (self, specific_used, true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;* Store the data and the sequence number so that we can recognize</span><br><span class="line">     stale data.  *&#x2F;</span><br><span class="line">  level2-&gt;seq &#x3D; seq;</span><br><span class="line">  level2-&gt;data &#x3D; (void *) value;</span><br><span class="line"></span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># define THREAD_SELF \</span><br><span class="line">((struct pthread *)__builtin_thread_pointer () - 1)</span><br><span class="line"></span><br><span class="line">struct pthread &#123;</span><br><span class="line">	......</span><br><span class="line">	struct pthread_key_data</span><br><span class="line">	&#123;</span><br><span class="line">	  &#x2F;* Sequence number.  We use uintptr_t to not require padding on</span><br><span class="line">	     32- and 64-bit machines.  On 64-bit machines it helps to avoid</span><br><span class="line">	     wrapping, too.  *&#x2F;</span><br><span class="line">	  uintptr_t seq;</span><br><span class="line">	</span><br><span class="line">	  &#x2F;* Data pointer.  *&#x2F;</span><br><span class="line">	  void *data;</span><br><span class="line">	&#125; specific_1stblock[PTHREAD_KEY_2NDLEVEL_SIZE];</span><br><span class="line">	</span><br><span class="line">	&#x2F;* Two-level array for the thread-specific data.  *&#x2F;</span><br><span class="line">	struct pthread_key_data *specific[PTHREAD_KEY_1STLEVEL_SIZE];</span><br><span class="line">	</span><br><span class="line">	&#x2F;* Flag which is set when specific data is set.  *&#x2F;</span><br><span class="line">	bool specific_used;</span><br><span class="line">	......</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>pthread_getspecific<br>获取TLS变量的代码和设置TLS变量代码类似,这里就不再分析了,pthread_getspecific的实现在nptl/pthread_getspecific.c中.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">void *</span><br><span class="line">__pthread_getspecific (pthread_key_t key)</span><br><span class="line">&#123;</span><br><span class="line">  struct pthread_key_data *data;</span><br><span class="line"></span><br><span class="line">  &#x2F;* Special case access to the first 2nd-level block.  This is the</span><br><span class="line">     usual case.  *&#x2F;</span><br><span class="line">  if (__glibc_likely (key &lt; PTHREAD_KEY_2NDLEVEL_SIZE))</span><br><span class="line">    data &#x3D; &amp;THREAD_SELF-&gt;specific_1stblock[key];</span><br><span class="line">  else</span><br><span class="line">    &#123;</span><br><span class="line">      &#x2F;* Verify the key is sane.  *&#x2F;</span><br><span class="line">      if (key &gt;&#x3D; PTHREAD_KEYS_MAX)</span><br><span class="line">	&#x2F;* Not valid.  *&#x2F;</span><br><span class="line">	return NULL;</span><br><span class="line"></span><br><span class="line">      unsigned int idx1st &#x3D; key &#x2F; PTHREAD_KEY_2NDLEVEL_SIZE;</span><br><span class="line">      unsigned int idx2nd &#x3D; key % PTHREAD_KEY_2NDLEVEL_SIZE;</span><br><span class="line"></span><br><span class="line">      &#x2F;* If the sequence number doesn&#39;t match or the key cannot be defined</span><br><span class="line">	 for this thread since the second level array is not allocated</span><br><span class="line">	 return NULL, too.  *&#x2F;</span><br><span class="line">      struct pthread_key_data *level2 &#x3D; THREAD_GETMEM_NC (THREAD_SELF,</span><br><span class="line">							  specific, idx1st);</span><br><span class="line">      if (level2 &#x3D;&#x3D; NULL)</span><br><span class="line">	&#x2F;* Not allocated, therefore no data.  *&#x2F;</span><br><span class="line">	return NULL;</span><br><span class="line"></span><br><span class="line">      &#x2F;* There is data.  *&#x2F;</span><br><span class="line">      data &#x3D; &amp;level2[idx2nd];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  void *result &#x3D; data-&gt;data;</span><br><span class="line">  if (result !&#x3D; NULL)</span><br><span class="line">    &#123;</span><br><span class="line">      uintptr_t seq &#x3D; data-&gt;seq;</span><br><span class="line"></span><br><span class="line">      if (__glibc_unlikely (seq !&#x3D; __pthread_keys[key].seq))</span><br><span class="line">	result &#x3D; data-&gt;data &#x3D; NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>pthread_key_delete<br>pthread_key_delete的实现是pthread_key_create实现的反过程,逻辑比较简单,这里也不再具体分析.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line">__pthread_key_delete (pthread_key_t key)</span><br><span class="line">&#123;</span><br><span class="line">  int result &#x3D; EINVAL;</span><br><span class="line"></span><br><span class="line">  if (__glibc_likely (key &lt; PTHREAD_KEYS_MAX))</span><br><span class="line">    &#123;</span><br><span class="line">      unsigned int seq &#x3D; __pthread_keys[key].seq;</span><br><span class="line"></span><br><span class="line">      if (__builtin_expect (! KEY_UNUSED (seq), 1)</span><br><span class="line">	  &amp;&amp; ! atomic_compare_and_exchange_bool_acq (&amp;__pthread_keys[key].seq,</span><br><span class="line">						     seq + 1, seq))</span><br><span class="line">	&#x2F;* We deleted a valid key.  *&#x2F;</span><br><span class="line">	result &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/22/ftrace-kprobe/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="The One">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="The One">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/22/ftrace-kprobe/" class="post-title-link" itemprop="url">Kprobe-based Event Tracing</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-22 21:54:33" itemprop="dateCreated datePublished" datetime="2019-12-22T21:54:33+08:00">2019-12-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-11-22 15:44:11" itemprop="dateModified" datetime="2020-11-22T15:44:11+08:00">2020-11-22</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>本文会介绍, 基于kprobe的内核调试方法<br>文章欢迎转载,但转载时请保留本段文字,并置于文章的顶部,作者:陈乐天,本文原文地址:<a target="_blank" rel="noopener" href="https://theonecwd.github.io/2019/12/22/ftrace-kprobe/#more">https://theonecwd.github.io/2019/12/22/ftrace-kprobe/#more</a></p>
</blockquote>
<p>内核提供了一些调试内核的工具，本文介绍其中的一种调试方法，该方法通过ftrace的借口提供kprobe功能，<br>通常情况下使用kprobe需要编写ko，并插入到内核来实现。有了ftrace的一些接口后，可以使操作变得简单。<br>本文来自内核文档，并在其基础上增加了一些内容，在下一篇文章中，将会举一些例子来进一步理解。</p>
<h2 id="Kprobe-based-Event-Tracing"><a href="#Kprobe-based-Event-Tracing" class="headerlink" title="Kprobe-based Event Tracing"></a>Kprobe-based Event Tracing</h2><blockquote>
<p>Author:    Masami Hiramatsu</p>
</blockquote>
<h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><p>These events are similar to tracepoint based events. Instead of Tracepoint, this is based on kprobes (kprobe and kretprobe).<br>So it can probe wherever kprobes can probe (this means,<br>all functions except those with __kprobes/nokprobe_inline annotation and those marked NOKPROBE_SYMBOL).<br>Unlike the Tracepoint based event, this can be added and removed dynamically, on the fly.</p>
<p>To enable this feature, build your kernel with CONFIG_KPROBE_EVENTS=y.</p>
<p>Similar to the events tracer, this doesn’t need to be activated via current_tracer. Instead of that,<br>add probe points via /sys/kernel/debug/tracing/kprobe_events,<br>and enable it via /sys/kernel/debug/tracing/events/kprobes/<EVENT>/enable.</p>
<p>You can also use /sys/kernel/debug/tracing/dynamic_events instead of kprobe_events.<br>That interface will provide unified access to other dynamic events too.</p>
<h3 id="Synopsis-of-kprobe-events"><a href="#Synopsis-of-kprobe-events" class="headerlink" title="Synopsis of kprobe_events"></a>Synopsis of kprobe_events</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"> p[:[GRP&#x2F;]EVENT] [MOD:]SYM[+offs]|MEMADDR [FETCHARGS]  : Set a probe</span><br><span class="line"> r[MAXACTIVE][:[GRP&#x2F;]EVENT] [MOD:]SYM[+0] [FETCHARGS]  : Set a return probe</span><br><span class="line"> -:[GRP&#x2F;]EVENT                                         : Clear a probe</span><br><span class="line"></span><br><span class="line">GRP            : Group name. If omitted, use &quot;kprobes&quot; for it.</span><br><span class="line">EVENT          : Event name. If omitted, the event name is generated</span><br><span class="line">                 based on SYM+offs or MEMADDR.</span><br><span class="line">MOD            : Module name which has given SYM.</span><br><span class="line">SYM[+offs]     : Symbol+offset where the probe is inserted.</span><br><span class="line">MEMADDR        : Address where the probe is inserted.</span><br><span class="line">MAXACTIVE      : Maximum number of instances of the specified function that</span><br><span class="line">                 can be probed simultaneously, or 0 for the default value</span><br><span class="line">                 as defined in Documentation&#x2F;kprobes.txt section 1.3.1.</span><br><span class="line"></span><br><span class="line">FETCHARGS      : Arguments. Each probe can have up to 128 args.</span><br><span class="line"> %REG          : Fetch register REG</span><br><span class="line"> @ADDR         : Fetch memory at ADDR (ADDR should be in kernel)</span><br><span class="line"> @SYM[+|-offs] : Fetch memory at SYM +|- offs (SYM should be a data symbol)</span><br><span class="line"> $stackN       : Fetch Nth entry of stack (N &gt;&#x3D; 0)</span><br><span class="line"> $stack        : Fetch stack address.</span><br><span class="line"> $argN         : Fetch the Nth function argument. (N &gt;&#x3D; 1) (\*1)</span><br><span class="line"> $retval       : Fetch return value.(\*2)</span><br><span class="line"> $comm         : Fetch current task comm.</span><br><span class="line"> +|-[u]OFFS(FETCHARG) : Fetch memory at FETCHARG +|- OFFS address.(\*3)(\*4)</span><br><span class="line"> \IMM          : Store an immediate value to the argument.</span><br><span class="line"> NAME&#x3D;FETCHARG : Set NAME as the argument name of FETCHARG.</span><br><span class="line"> FETCHARG:TYPE : Set TYPE as the type of FETCHARG. Currently, basic types</span><br><span class="line">                 (u8&#x2F;u16&#x2F;u32&#x2F;u64&#x2F;s8&#x2F;s16&#x2F;s32&#x2F;s64), hexadecimal types</span><br><span class="line">                 (x8&#x2F;x16&#x2F;x32&#x2F;x64), &quot;string&quot;, &quot;ustring&quot; and bitfield</span><br><span class="line">                 are supported.</span><br><span class="line"></span><br><span class="line"> (\*1) only for the probe on function entry (offs &#x3D;&#x3D; 0).</span><br><span class="line"> (\*2) only for return probe.</span><br><span class="line"> (\*3) this is useful for fetching a field of data structures.</span><br><span class="line"> (\*4) &quot;u&quot; means user-space dereference. See :ref:&#96;user_mem_access&#96;.</span><br></pre></td></tr></table></figure>

<h3 id="Types"><a href="#Types" class="headerlink" title="Types"></a>Types</h3><p>Several types are supported for fetch-args. Kprobe tracer will access memory by given type.<br>Prefix ‘s’ and ‘u’ means those types are signed and unsigned respectively. ‘x’ prefix implies it is unsigned.<br>Traced arguments are shown in decimal (‘s’ and ‘u’) or hexadecimal (‘x’).<br>Without type casting, ‘x32’ or ‘x64’ is used depends on the architecture (e.g. x86-32 uses x32, and x86-64 uses x64).<br>These value types can be an array. To record array data, you can add ‘[N]’ (where N is a fixed number,<br>less than 64) to the base type. E.g. ‘x16[4]’ means an array of x16 (2bytes hex) with 4 elements.<br>Note that the array can be applied to memory type fetchargs,<br>you can not apply it to registers/stack-entries etc. (for example, ‘$stack1:x8[8]’ is wrong, but ‘+8($stack):x8[8]’ is OK.)<br>String type is a special type, which fetches a “null-terminated” string from kernel space.<br>This means it will fail and store NULL if the string container has been paged out. “ustring” type is an alternative of string<br>for user-space. See user_mem_access for more info.. The string array type is a bit different from other types.<br>For other base types, <base-type>[1] is equal to <base-type> (e.g. +0(%di):x32[1] is same as +0(%di):x32.)<br>But string[1] is not equal to string. The string type itself represents “char array”,<br>but string array type represents “char * array”. So, for example, +0(%di):string[1] is equal to +0(+0(%di)):string.<br>Bitfield is another special type, which takes 3 parameters, bit-width, bit- offset, and container-size (usually 32).<br>The syntax is:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b&lt;bit-width&gt;@&lt;bit-offset&gt;&#x2F;&lt;container-size&gt;</span><br></pre></td></tr></table></figure>
<p>Symbol type(‘symbol’) is an alias of u32 or u64 type (depends on BITS_PER_LONG)<br>which shows given pointer in “symbol+offset” style. For $comm, the default type is “string”; any other type is invalid.</p>
<h3 id="User-Memory-Access"><a href="#User-Memory-Access" class="headerlink" title="User Memory Access"></a>User Memory Access</h3><p>Kprobe events supports user-space memory access.<br>For that purpose, you can use either user-space dereference syntax or ‘ustring’ type.</p>
<p>The user-space dereference syntax allows you to access a field of a data structure in user-space.<br>This is done by adding the “u” prefix to the dereference syntax.<br>For example, +u4(%si) means it will read memory from the address in the register %si offset by 4,<br>and the memory is expected to be in user-space.<br>You can use this for strings too,<br>e.g. +u0(%si):string will read a string from the address in the register %si that is expected to be in user- space.<br>‘ustring’ is a shortcut way of performing the same task.<br>That is, +0(%si):ustring is equivalent to +u0(%si):string.</p>
<p>Note that kprobe-event provides the user-memory access syntax but it doesn’t use it transparently.<br>This means if you use normal dereference or string type for user memory, it might fail, and may always fail on some archs.<br>The user has to carefully check if the target data is in kernel or user space.</p>
<h3 id="Per-Probe-Event-Filtering"><a href="#Per-Probe-Event-Filtering" class="headerlink" title="Per-Probe Event Filtering"></a>Per-Probe Event Filtering</h3><p>Per-probe event filtering feature allows you to set different filter on each probe and<br>gives you what arguments will be shown in trace buffer.<br>If an event name is specified right after ‘p:’ or ‘r:’ in kprobe_events,<br>it adds an event under tracing/events/kprobes/<EVENT>,<br>at the directory you can see ‘id’, ‘enable’, ‘format’, ‘filter’ and ‘trigger’.</p>
<p><strong>enable</strong>:<br>    You can enable/disable the probe by writing 1 or 0 on it.<br><strong>format</strong>:<br>    This shows the format of this probe event.<br><strong>filter</strong>:<br>    You can write filtering rules of this event.<br><strong>id</strong>:<br>    This shows the id of this probe event.<br><strong>trigger</strong>:<br>    This allows to install trigger commands which are executed when the event is hit<br>    (for details, see Documentation/trace/events.rst, section 6). </p>
<h3 id="Event-Profiling"><a href="#Event-Profiling" class="headerlink" title="Event Profiling"></a>Event Profiling</h3><p>You can check the total number of probe hits and probe miss-hits via /sys/kernel/debug/tracing/kprobe_profile.<br>The first column is event name, the second is the number of probe hits, the third is the number of probe miss-hits.</p>
<h3 id="Kernel-Boot-Parameter"><a href="#Kernel-Boot-Parameter" class="headerlink" title="Kernel Boot Parameter"></a>Kernel Boot Parameter</h3><p>You can add and enable new kprobe events when booting up the kernel by “kprobe_event=” parameter.<br>The parameter accepts a semicolon-delimited kprobe events, which format is similar to the kprobe_events.<br>The difference is that the probe definition parameters are comma-delimited instead of space.<br>For example, adding myprobe event on do_sys_open like below</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p:myprobe do_sys_open dfd&#x3D;%ax filename&#x3D;%dx flags&#x3D;%cx mode&#x3D;+4($stack)</span><br></pre></td></tr></table></figure>

<p>when specific parameter type</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p:myprobe do_sys_open dfd&#x3D;%ax:u32 filename&#x3D;%dx flags&#x3D;%cx mode&#x3D;+4($stack)</span><br></pre></td></tr></table></figure>


<p>should be below for kernel boot parameter (just replace spaces with comma)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p:myprobe,do_sys_open,dfd&#x3D;%ax,filename&#x3D;%dx,flags&#x3D;%cx,mode&#x3D;+4($stack)</span><br></pre></td></tr></table></figure>
<h3 id="Usage-examples"><a href="#Usage-examples" class="headerlink" title="Usage examples"></a>Usage examples</h3><p>To add a probe as a new event, write a new definition to kprobe_events as below:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &#39;p:myprobe do_sys_open dfd&#x3D;%ax filename&#x3D;%dx flags&#x3D;%cx mode&#x3D;+4($stack)&#39; &gt; &#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;tracing&#x2F;kprobe_events</span><br></pre></td></tr></table></figure>

<p>This sets a kprobe on the top of do_sys_open() function with recording 1st to 4th arguments as “myprobe” event.<br>Note, which register/stack entry is assigned to each function argument depends on arch-specific ABI.<br>If you unsure the ABI, please try to use probe subcommand of perf-tools (you can find it under tools/perf/).<br>As this example shows, users can choose more familiar names for each arguments.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &#39;r:myretprobe do_sys_open $retval&#39; &gt;&gt; &#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;tracing&#x2F;kprobe_events</span><br></pre></td></tr></table></figure>

<p>This sets a kretprobe on the return point of do_sys_open() function with recording return value as “myretprobe” event.<br>You can see the format of these events via /sys/kernel/debug/tracing/events/kprobes/<EVENT>/format.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;tracing&#x2F;events&#x2F;kprobes&#x2F;myprobe&#x2F;format</span><br><span class="line">name: myprobe</span><br><span class="line">ID: 780</span><br><span class="line">format:</span><br><span class="line">        field:unsigned short common_type;       offset:0;       size:2; signed:0;</span><br><span class="line">        field:unsigned char common_flags;       offset:2;       size:1; signed:0;</span><br><span class="line">        field:unsigned char common_preempt_count;       offset:3; size:1;signed:0;</span><br><span class="line">        field:int common_pid;   offset:4;       size:4; signed:1;</span><br><span class="line"></span><br><span class="line">        field:unsigned long __probe_ip; offset:12;      size:4; signed:0;</span><br><span class="line">        field:int __probe_nargs;        offset:16;      size:4; signed:1;</span><br><span class="line">        field:unsigned long dfd;        offset:20;      size:4; signed:0;</span><br><span class="line">        field:unsigned long filename;   offset:24;      size:4; signed:0;</span><br><span class="line">        field:unsigned long flags;      offset:28;      size:4; signed:0;</span><br><span class="line">        field:unsigned long mode;       offset:32;      size:4; signed:0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print fmt: &quot;(%lx) dfd&#x3D;%lx filename&#x3D;%lx flags&#x3D;%lx mode&#x3D;%lx&quot;, REC-&gt;__probe_ip,</span><br><span class="line">REC-&gt;dfd, REC-&gt;filename, REC-&gt;flags, REC-&gt;mode</span><br></pre></td></tr></table></figure>

<p>You can see that the event has 4 arguments as in the expressions you specified.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &gt; &#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;tracing&#x2F;kprobe_events</span><br></pre></td></tr></table></figure>

<p>This clears all probe points.</p>
<blockquote>
<blockquote>
<p>这里需要注意的是如果要删除event，需要先disable</p>
</blockquote>
</blockquote>
<p>Or,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo -:myprobe &gt;&gt; kprobe_events</span><br></pre></td></tr></table></figure>

<p>This clears probe points selectively.</p>
<p>Right after definition, each event is disabled by default. For tracing these events, you need to enable it.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo 1 &gt; &#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;tracing&#x2F;events&#x2F;kprobes&#x2F;myprobe&#x2F;enable</span><br><span class="line">echo 1 &gt; &#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;tracing&#x2F;events&#x2F;kprobes&#x2F;myretprobe&#x2F;enable</span><br></pre></td></tr></table></figure>
<p>when disable</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo 0 &gt; &#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;tracing&#x2F;events&#x2F;kprobes&#x2F;myprobe&#x2F;enable</span><br><span class="line">echo 0 &gt; &#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;tracing&#x2F;events&#x2F;kprobes&#x2F;myretprobe&#x2F;enable</span><br></pre></td></tr></table></figure>

<p>Use the following command to start tracing in an interval.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># echo 1 &gt; tracing_on</span><br><span class="line">Open something...</span><br><span class="line"># echo 0 &gt; tracing_on</span><br></pre></td></tr></table></figure>

<p>And you can see the traced information via /sys/kernel/debug/tracing/trace.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;tracing&#x2F;trace</span><br><span class="line"># tracer: nop</span><br><span class="line">#</span><br><span class="line">#           TASK-PID    CPU#    TIMESTAMP  FUNCTION</span><br><span class="line">#              | |       |          |         |</span><br><span class="line">           &lt;...&gt;-1447  [001] 1038282.286875: myprobe: (do_sys_open+0x0&#x2F;0xd6) dfd&#x3D;3 filename&#x3D;7fffd1ec4440 flags&#x3D;8000 mode&#x3D;0</span><br><span class="line">           &lt;...&gt;-1447  [001] 1038282.286878: myretprobe: (sys_openat+0xc&#x2F;0xe &lt;- do_sys_open) $retval&#x3D;fffffffffffffffe</span><br><span class="line">           &lt;...&gt;-1447  [001] 1038282.286885: myprobe: (do_sys_open+0x0&#x2F;0xd6) dfd&#x3D;ffffff9c filename&#x3D;40413c flags&#x3D;8000 mode&#x3D;1b6</span><br><span class="line">           &lt;...&gt;-1447  [001] 1038282.286915: myretprobe: (sys_open+0x1b&#x2F;0x1d &lt;- do_sys_open) $retval&#x3D;3</span><br><span class="line">           &lt;...&gt;-1447  [001] 1038282.286969: myprobe: (do_sys_open+0x0&#x2F;0xd6) dfd&#x3D;ffffff9c filename&#x3D;4041c6 flags&#x3D;98800 mode&#x3D;10</span><br><span class="line">           &lt;...&gt;-1447  [001] 1038282.286976: myretprobe: (sys_open+0x1b&#x2F;0x1d &lt;- do_sys_open) $retval&#x3D;3</span><br></pre></td></tr></table></figure>
<p>Each line shows when the kernel hits an event, and &lt;- SYMBOL means kernel returns from SYMBOL<br>(e.g. “sys_open+0x1b/0x1d &lt;- do_sys_open” means kernel returns from do_sys_open to sys_open+0x1b).</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/23/page-flags/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="The One">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="The One">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/06/23/page-flags/" class="post-title-link" itemprop="url">page-flags</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-06-23 13:55:43" itemprop="dateCreated datePublished" datetime="2019-06-23T13:55:43+08:00">2019-06-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-11-22 15:44:11" itemprop="dateModified" datetime="2020-11-22T15:44:11+08:00">2020-11-22</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PAGE_ACCESSED</span><br><span class="line">PAGE_REFERENCED</span><br><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/01/linux-kernel-zsmalloc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="The One">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="The One">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/12/01/linux-kernel-zsmalloc/" class="post-title-link" itemprop="url">linux kernel zsmalloc</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-12-01 21:32:02" itemprop="dateCreated datePublished" datetime="2018-12-01T21:32:02+08:00">2018-12-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-11-22 15:44:11" itemprop="dateModified" datetime="2020-11-22T15:44:11+08:00">2020-11-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux-kernel/" itemprop="url" rel="index"><span itemprop="name">linux kernel</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>show me the code </p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">The One</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">7</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">The One</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
